// Code generated by SQLBoiler 4.8.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package boiler

import (
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Collection is an object representing the database table.
type Collection struct {
	ID                 string           `boiler:"id" boil:"id" json:"id" toml:"id" yaml:"id"`
	Name               string           `boiler:"name" boil:"name" json:"name" toml:"name" yaml:"name"`
	LogoBlobID         null.String      `boiler:"logo_blob_id" boil:"logo_blob_id" json:"logo_blob_id,omitempty" toml:"logo_blob_id" yaml:"logo_blob_id,omitempty"`
	Keywords           null.String      `boiler:"keywords" boil:"keywords" json:"keywords,omitempty" toml:"keywords" yaml:"keywords,omitempty"`
	DeletedAt          null.Time        `boiler:"deleted_at" boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	UpdatedAt          time.Time        `boiler:"updated_at" boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	CreatedAt          time.Time        `boiler:"created_at" boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	Slug               string           `boiler:"slug" boil:"slug" json:"slug" toml:"slug" yaml:"slug"`
	MintContract       null.String      `boiler:"mint_contract" boil:"mint_contract" json:"mint_contract,omitempty" toml:"mint_contract" yaml:"mint_contract,omitempty"`
	StakeContract      null.String      `boiler:"stake_contract" boil:"stake_contract" json:"stake_contract,omitempty" toml:"stake_contract" yaml:"stake_contract,omitempty"`
	IsVisible          null.Bool        `boiler:"is_visible" boil:"is_visible" json:"is_visible,omitempty" toml:"is_visible" yaml:"is_visible,omitempty"`
	ContractType       null.String      `boiler:"contract_type" boil:"contract_type" json:"contract_type,omitempty" toml:"contract_type" yaml:"contract_type,omitempty"`
	StakingContractOld null.String      `boiler:"staking_contract_old" boil:"staking_contract_old" json:"staking_contract_old,omitempty" toml:"staking_contract_old" yaml:"staking_contract_old,omitempty"`
	BackgroundURL      null.String      `boiler:"background_url" boil:"background_url" json:"background_url,omitempty" toml:"background_url" yaml:"background_url,omitempty"`
	LogoURL            null.String      `boiler:"logo_url" boil:"logo_url" json:"logo_url,omitempty" toml:"logo_url" yaml:"logo_url,omitempty"`
	Description        null.String      `boiler:"description" boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	ExternalTokenIds   types.Int64Array `boiler:"external_token_ids" boil:"external_token_ids" json:"external_token_ids,omitempty" toml:"external_token_ids" yaml:"external_token_ids,omitempty"`
	TransferContract   null.String      `boiler:"transfer_contract" boil:"transfer_contract" json:"transfer_contract,omitempty" toml:"transfer_contract" yaml:"transfer_contract,omitempty"`

	R *collectionR `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
	L collectionL  `boiler:"-" boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CollectionColumns = struct {
	ID                 string
	Name               string
	LogoBlobID         string
	Keywords           string
	DeletedAt          string
	UpdatedAt          string
	CreatedAt          string
	Slug               string
	MintContract       string
	StakeContract      string
	IsVisible          string
	ContractType       string
	StakingContractOld string
	BackgroundURL      string
	LogoURL            string
	Description        string
	ExternalTokenIds   string
	TransferContract   string
}{
	ID:                 "id",
	Name:               "name",
	LogoBlobID:         "logo_blob_id",
	Keywords:           "keywords",
	DeletedAt:          "deleted_at",
	UpdatedAt:          "updated_at",
	CreatedAt:          "created_at",
	Slug:               "slug",
	MintContract:       "mint_contract",
	StakeContract:      "stake_contract",
	IsVisible:          "is_visible",
	ContractType:       "contract_type",
	StakingContractOld: "staking_contract_old",
	BackgroundURL:      "background_url",
	LogoURL:            "logo_url",
	Description:        "description",
	ExternalTokenIds:   "external_token_ids",
	TransferContract:   "transfer_contract",
}

var CollectionTableColumns = struct {
	ID                 string
	Name               string
	LogoBlobID         string
	Keywords           string
	DeletedAt          string
	UpdatedAt          string
	CreatedAt          string
	Slug               string
	MintContract       string
	StakeContract      string
	IsVisible          string
	ContractType       string
	StakingContractOld string
	BackgroundURL      string
	LogoURL            string
	Description        string
	ExternalTokenIds   string
	TransferContract   string
}{
	ID:                 "collections.id",
	Name:               "collections.name",
	LogoBlobID:         "collections.logo_blob_id",
	Keywords:           "collections.keywords",
	DeletedAt:          "collections.deleted_at",
	UpdatedAt:          "collections.updated_at",
	CreatedAt:          "collections.created_at",
	Slug:               "collections.slug",
	MintContract:       "collections.mint_contract",
	StakeContract:      "collections.stake_contract",
	IsVisible:          "collections.is_visible",
	ContractType:       "collections.contract_type",
	StakingContractOld: "collections.staking_contract_old",
	BackgroundURL:      "collections.background_url",
	LogoURL:            "collections.logo_url",
	Description:        "collections.description",
	ExternalTokenIds:   "collections.external_token_ids",
	TransferContract:   "collections.transfer_contract",
}

// Generated where

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertypes_Int64Array struct{ field string }

func (w whereHelpertypes_Int64Array) EQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_Int64Array) NEQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_Int64Array) LT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Int64Array) LTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Int64Array) GT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Int64Array) GTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_Int64Array) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_Int64Array) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var CollectionWhere = struct {
	ID                 whereHelperstring
	Name               whereHelperstring
	LogoBlobID         whereHelpernull_String
	Keywords           whereHelpernull_String
	DeletedAt          whereHelpernull_Time
	UpdatedAt          whereHelpertime_Time
	CreatedAt          whereHelpertime_Time
	Slug               whereHelperstring
	MintContract       whereHelpernull_String
	StakeContract      whereHelpernull_String
	IsVisible          whereHelpernull_Bool
	ContractType       whereHelpernull_String
	StakingContractOld whereHelpernull_String
	BackgroundURL      whereHelpernull_String
	LogoURL            whereHelpernull_String
	Description        whereHelpernull_String
	ExternalTokenIds   whereHelpertypes_Int64Array
	TransferContract   whereHelpernull_String
}{
	ID:                 whereHelperstring{field: "\"collections\".\"id\""},
	Name:               whereHelperstring{field: "\"collections\".\"name\""},
	LogoBlobID:         whereHelpernull_String{field: "\"collections\".\"logo_blob_id\""},
	Keywords:           whereHelpernull_String{field: "\"collections\".\"keywords\""},
	DeletedAt:          whereHelpernull_Time{field: "\"collections\".\"deleted_at\""},
	UpdatedAt:          whereHelpertime_Time{field: "\"collections\".\"updated_at\""},
	CreatedAt:          whereHelpertime_Time{field: "\"collections\".\"created_at\""},
	Slug:               whereHelperstring{field: "\"collections\".\"slug\""},
	MintContract:       whereHelpernull_String{field: "\"collections\".\"mint_contract\""},
	StakeContract:      whereHelpernull_String{field: "\"collections\".\"stake_contract\""},
	IsVisible:          whereHelpernull_Bool{field: "\"collections\".\"is_visible\""},
	ContractType:       whereHelpernull_String{field: "\"collections\".\"contract_type\""},
	StakingContractOld: whereHelpernull_String{field: "\"collections\".\"staking_contract_old\""},
	BackgroundURL:      whereHelpernull_String{field: "\"collections\".\"background_url\""},
	LogoURL:            whereHelpernull_String{field: "\"collections\".\"logo_url\""},
	Description:        whereHelpernull_String{field: "\"collections\".\"description\""},
	ExternalTokenIds:   whereHelpertypes_Int64Array{field: "\"collections\".\"external_token_ids\""},
	TransferContract:   whereHelpernull_String{field: "\"collections\".\"transfer_contract\""},
}

// CollectionRels is where relationship names are stored.
var CollectionRels = struct {
	LogoBlob                string
	ItemOnchainTransactions string
	PurchasedItemsOlds      string
	StoreItems              string
	UserAssets              string
	UserAssets1155S         string
}{
	LogoBlob:                "LogoBlob",
	ItemOnchainTransactions: "ItemOnchainTransactions",
	PurchasedItemsOlds:      "PurchasedItemsOlds",
	StoreItems:              "StoreItems",
	UserAssets:              "UserAssets",
	UserAssets1155S:         "UserAssets1155S",
}

// collectionR is where relationships are stored.
type collectionR struct {
	LogoBlob                *Blob                       `boiler:"LogoBlob" boil:"LogoBlob" json:"LogoBlob" toml:"LogoBlob" yaml:"LogoBlob"`
	ItemOnchainTransactions ItemOnchainTransactionSlice `boiler:"ItemOnchainTransactions" boil:"ItemOnchainTransactions" json:"ItemOnchainTransactions" toml:"ItemOnchainTransactions" yaml:"ItemOnchainTransactions"`
	PurchasedItemsOlds      PurchasedItemsOldSlice      `boiler:"PurchasedItemsOlds" boil:"PurchasedItemsOlds" json:"PurchasedItemsOlds" toml:"PurchasedItemsOlds" yaml:"PurchasedItemsOlds"`
	StoreItems              StoreItemSlice              `boiler:"StoreItems" boil:"StoreItems" json:"StoreItems" toml:"StoreItems" yaml:"StoreItems"`
	UserAssets              UserAssetSlice              `boiler:"UserAssets" boil:"UserAssets" json:"UserAssets" toml:"UserAssets" yaml:"UserAssets"`
	UserAssets1155S         UserAssets1155Slice         `boiler:"UserAssets1155S" boil:"UserAssets1155S" json:"UserAssets1155S" toml:"UserAssets1155S" yaml:"UserAssets1155S"`
}

// NewStruct creates a new relationship struct
func (*collectionR) NewStruct() *collectionR {
	return &collectionR{}
}

// collectionL is where Load methods for each relationship are stored.
type collectionL struct{}

var (
	collectionAllColumns            = []string{"id", "name", "logo_blob_id", "keywords", "deleted_at", "updated_at", "created_at", "slug", "mint_contract", "stake_contract", "is_visible", "contract_type", "staking_contract_old", "background_url", "logo_url", "description", "external_token_ids", "transfer_contract"}
	collectionColumnsWithoutDefault = []string{"name", "logo_blob_id", "keywords", "deleted_at", "slug", "mint_contract", "contract_type", "staking_contract_old", "background_url", "logo_url", "description", "external_token_ids", "transfer_contract"}
	collectionColumnsWithDefault    = []string{"id", "updated_at", "created_at", "stake_contract", "is_visible"}
	collectionPrimaryKeyColumns     = []string{"id"}
)

type (
	// CollectionSlice is an alias for a slice of pointers to Collection.
	// This should almost always be used instead of []Collection.
	CollectionSlice []*Collection
	// CollectionHook is the signature for custom Collection hook methods
	CollectionHook func(boil.Executor, *Collection) error

	collectionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	collectionType                 = reflect.TypeOf(&Collection{})
	collectionMapping              = queries.MakeStructMapping(collectionType)
	collectionPrimaryKeyMapping, _ = queries.BindMapping(collectionType, collectionMapping, collectionPrimaryKeyColumns)
	collectionInsertCacheMut       sync.RWMutex
	collectionInsertCache          = make(map[string]insertCache)
	collectionUpdateCacheMut       sync.RWMutex
	collectionUpdateCache          = make(map[string]updateCache)
	collectionUpsertCacheMut       sync.RWMutex
	collectionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var collectionBeforeInsertHooks []CollectionHook
var collectionBeforeUpdateHooks []CollectionHook
var collectionBeforeDeleteHooks []CollectionHook
var collectionBeforeUpsertHooks []CollectionHook

var collectionAfterInsertHooks []CollectionHook
var collectionAfterSelectHooks []CollectionHook
var collectionAfterUpdateHooks []CollectionHook
var collectionAfterDeleteHooks []CollectionHook
var collectionAfterUpsertHooks []CollectionHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Collection) doBeforeInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionBeforeInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Collection) doBeforeUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionBeforeUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Collection) doBeforeDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionBeforeDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Collection) doBeforeUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionBeforeUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Collection) doAfterInsertHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionAfterInsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Collection) doAfterSelectHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionAfterSelectHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Collection) doAfterUpdateHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionAfterUpdateHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Collection) doAfterDeleteHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionAfterDeleteHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Collection) doAfterUpsertHooks(exec boil.Executor) (err error) {
	for _, hook := range collectionAfterUpsertHooks {
		if err := hook(exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCollectionHook registers your hook function for all future operations.
func AddCollectionHook(hookPoint boil.HookPoint, collectionHook CollectionHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		collectionBeforeInsertHooks = append(collectionBeforeInsertHooks, collectionHook)
	case boil.BeforeUpdateHook:
		collectionBeforeUpdateHooks = append(collectionBeforeUpdateHooks, collectionHook)
	case boil.BeforeDeleteHook:
		collectionBeforeDeleteHooks = append(collectionBeforeDeleteHooks, collectionHook)
	case boil.BeforeUpsertHook:
		collectionBeforeUpsertHooks = append(collectionBeforeUpsertHooks, collectionHook)
	case boil.AfterInsertHook:
		collectionAfterInsertHooks = append(collectionAfterInsertHooks, collectionHook)
	case boil.AfterSelectHook:
		collectionAfterSelectHooks = append(collectionAfterSelectHooks, collectionHook)
	case boil.AfterUpdateHook:
		collectionAfterUpdateHooks = append(collectionAfterUpdateHooks, collectionHook)
	case boil.AfterDeleteHook:
		collectionAfterDeleteHooks = append(collectionAfterDeleteHooks, collectionHook)
	case boil.AfterUpsertHook:
		collectionAfterUpsertHooks = append(collectionAfterUpsertHooks, collectionHook)
	}
}

// One returns a single collection record from the query.
func (q collectionQuery) One(exec boil.Executor) (*Collection, error) {
	o := &Collection{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(nil, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: failed to execute a one query for collections")
	}

	if err := o.doAfterSelectHooks(exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Collection records from the query.
func (q collectionQuery) All(exec boil.Executor) (CollectionSlice, error) {
	var o []*Collection

	err := q.Bind(nil, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "boiler: failed to assign all query results to Collection slice")
	}

	if len(collectionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Collection records in the query.
func (q collectionQuery) Count(exec boil.Executor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to count collections rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q collectionQuery) Exists(exec boil.Executor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRow(exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "boiler: failed to check if collections exists")
	}

	return count > 0, nil
}

// LogoBlob pointed to by the foreign key.
func (o *Collection) LogoBlob(mods ...qm.QueryMod) blobQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.LogoBlobID),
		qmhelper.WhereIsNull("deleted_at"),
	}

	queryMods = append(queryMods, mods...)

	query := Blobs(queryMods...)
	queries.SetFrom(query.Query, "\"blobs\"")

	return query
}

// ItemOnchainTransactions retrieves all the item_onchain_transaction's ItemOnchainTransactions with an executor.
func (o *Collection) ItemOnchainTransactions(mods ...qm.QueryMod) itemOnchainTransactionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"item_onchain_transactions\".\"collection_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"item_onchain_transactions\".\"deleted_at\""),
	)

	query := ItemOnchainTransactions(queryMods...)
	queries.SetFrom(query.Query, "\"item_onchain_transactions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"item_onchain_transactions\".*"})
	}

	return query
}

// PurchasedItemsOlds retrieves all the purchased_items_old's PurchasedItemsOlds with an executor.
func (o *Collection) PurchasedItemsOlds(mods ...qm.QueryMod) purchasedItemsOldQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"purchased_items_old\".\"collection_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"purchased_items_old\".\"deleted_at\""),
	)

	query := PurchasedItemsOlds(queryMods...)
	queries.SetFrom(query.Query, "\"purchased_items_old\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"purchased_items_old\".*"})
	}

	return query
}

// StoreItems retrieves all the store_item's StoreItems with an executor.
func (o *Collection) StoreItems(mods ...qm.QueryMod) storeItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"store_items\".\"collection_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"store_items\".\"deleted_at\""),
	)

	query := StoreItems(queryMods...)
	queries.SetFrom(query.Query, "\"store_items\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"store_items\".*"})
	}

	return query
}

// UserAssets retrieves all the user_asset's UserAssets with an executor.
func (o *Collection) UserAssets(mods ...qm.QueryMod) userAssetQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_assets\".\"collection_id\"=?", o.ID),
		qmhelper.WhereIsNull("\"user_assets\".\"deleted_at\""),
	)

	query := UserAssets(queryMods...)
	queries.SetFrom(query.Query, "\"user_assets\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_assets\".*"})
	}

	return query
}

// UserAssets1155S retrieves all the user_assets_1155's UserAssets1155S with an executor.
func (o *Collection) UserAssets1155S(mods ...qm.QueryMod) userAssets1155Query {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_assets_1155\".\"collection_id\"=?", o.ID),
	)

	query := UserAssets1155S(queryMods...)
	queries.SetFrom(query.Query, "\"user_assets_1155\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_assets_1155\".*"})
	}

	return query
}

// LoadLogoBlob allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (collectionL) LoadLogoBlob(e boil.Executor, singular bool, maybeCollection interface{}, mods queries.Applicator) error {
	var slice []*Collection
	var object *Collection

	if singular {
		object = maybeCollection.(*Collection)
	} else {
		slice = *maybeCollection.(*[]*Collection)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &collectionR{}
		}
		if !queries.IsNil(object.LogoBlobID) {
			args = append(args, object.LogoBlobID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &collectionR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.LogoBlobID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.LogoBlobID) {
				args = append(args, obj.LogoBlobID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`blobs`),
		qm.WhereIn(`blobs.id in ?`, args...),
		qmhelper.WhereIsNull(`blobs.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Blob")
	}

	var resultSlice []*Blob
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Blob")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for blobs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for blobs")
	}

	if len(collectionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.LogoBlob = foreign
		if foreign.R == nil {
			foreign.R = &blobR{}
		}
		foreign.R.LogoBlobCollections = append(foreign.R.LogoBlobCollections, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.LogoBlobID, foreign.ID) {
				local.R.LogoBlob = foreign
				if foreign.R == nil {
					foreign.R = &blobR{}
				}
				foreign.R.LogoBlobCollections = append(foreign.R.LogoBlobCollections, local)
				break
			}
		}
	}

	return nil
}

// LoadItemOnchainTransactions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (collectionL) LoadItemOnchainTransactions(e boil.Executor, singular bool, maybeCollection interface{}, mods queries.Applicator) error {
	var slice []*Collection
	var object *Collection

	if singular {
		object = maybeCollection.(*Collection)
	} else {
		slice = *maybeCollection.(*[]*Collection)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &collectionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &collectionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`item_onchain_transactions`),
		qm.WhereIn(`item_onchain_transactions.collection_id in ?`, args...),
		qmhelper.WhereIsNull(`item_onchain_transactions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load item_onchain_transactions")
	}

	var resultSlice []*ItemOnchainTransaction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice item_onchain_transactions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on item_onchain_transactions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for item_onchain_transactions")
	}

	if len(itemOnchainTransactionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ItemOnchainTransactions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &itemOnchainTransactionR{}
			}
			foreign.R.Collection = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CollectionID {
				local.R.ItemOnchainTransactions = append(local.R.ItemOnchainTransactions, foreign)
				if foreign.R == nil {
					foreign.R = &itemOnchainTransactionR{}
				}
				foreign.R.Collection = local
				break
			}
		}
	}

	return nil
}

// LoadPurchasedItemsOlds allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (collectionL) LoadPurchasedItemsOlds(e boil.Executor, singular bool, maybeCollection interface{}, mods queries.Applicator) error {
	var slice []*Collection
	var object *Collection

	if singular {
		object = maybeCollection.(*Collection)
	} else {
		slice = *maybeCollection.(*[]*Collection)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &collectionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &collectionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`purchased_items_old`),
		qm.WhereIn(`purchased_items_old.collection_id in ?`, args...),
		qmhelper.WhereIsNull(`purchased_items_old.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load purchased_items_old")
	}

	var resultSlice []*PurchasedItemsOld
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice purchased_items_old")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on purchased_items_old")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for purchased_items_old")
	}

	if len(purchasedItemsOldAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PurchasedItemsOlds = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &purchasedItemsOldR{}
			}
			foreign.R.Collection = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CollectionID {
				local.R.PurchasedItemsOlds = append(local.R.PurchasedItemsOlds, foreign)
				if foreign.R == nil {
					foreign.R = &purchasedItemsOldR{}
				}
				foreign.R.Collection = local
				break
			}
		}
	}

	return nil
}

// LoadStoreItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (collectionL) LoadStoreItems(e boil.Executor, singular bool, maybeCollection interface{}, mods queries.Applicator) error {
	var slice []*Collection
	var object *Collection

	if singular {
		object = maybeCollection.(*Collection)
	} else {
		slice = *maybeCollection.(*[]*Collection)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &collectionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &collectionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`store_items`),
		qm.WhereIn(`store_items.collection_id in ?`, args...),
		qmhelper.WhereIsNull(`store_items.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load store_items")
	}

	var resultSlice []*StoreItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice store_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on store_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for store_items")
	}

	if len(storeItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.StoreItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &storeItemR{}
			}
			foreign.R.Collection = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CollectionID {
				local.R.StoreItems = append(local.R.StoreItems, foreign)
				if foreign.R == nil {
					foreign.R = &storeItemR{}
				}
				foreign.R.Collection = local
				break
			}
		}
	}

	return nil
}

// LoadUserAssets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (collectionL) LoadUserAssets(e boil.Executor, singular bool, maybeCollection interface{}, mods queries.Applicator) error {
	var slice []*Collection
	var object *Collection

	if singular {
		object = maybeCollection.(*Collection)
	} else {
		slice = *maybeCollection.(*[]*Collection)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &collectionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &collectionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_assets`),
		qm.WhereIn(`user_assets.collection_id in ?`, args...),
		qmhelper.WhereIsNull(`user_assets.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_assets")
	}

	var resultSlice []*UserAsset
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_assets")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_assets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_assets")
	}

	if len(userAssetAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserAssets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAssetR{}
			}
			foreign.R.Collection = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CollectionID {
				local.R.UserAssets = append(local.R.UserAssets, foreign)
				if foreign.R == nil {
					foreign.R = &userAssetR{}
				}
				foreign.R.Collection = local
				break
			}
		}
	}

	return nil
}

// LoadUserAssets1155S allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (collectionL) LoadUserAssets1155S(e boil.Executor, singular bool, maybeCollection interface{}, mods queries.Applicator) error {
	var slice []*Collection
	var object *Collection

	if singular {
		object = maybeCollection.(*Collection)
	} else {
		slice = *maybeCollection.(*[]*Collection)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &collectionR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &collectionR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user_assets_1155`),
		qm.WhereIn(`user_assets_1155.collection_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.Query(e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_assets_1155")
	}

	var resultSlice []*UserAssets1155
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_assets_1155")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_assets_1155")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_assets_1155")
	}

	if len(userAssets1155AfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserAssets1155S = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAssets1155R{}
			}
			foreign.R.Collection = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CollectionID {
				local.R.UserAssets1155S = append(local.R.UserAssets1155S, foreign)
				if foreign.R == nil {
					foreign.R = &userAssets1155R{}
				}
				foreign.R.Collection = local
				break
			}
		}
	}

	return nil
}

// SetLogoBlob of the collection to the related item.
// Sets o.R.LogoBlob to related.
// Adds o to related.R.LogoBlobCollections.
func (o *Collection) SetLogoBlob(exec boil.Executor, insert bool, related *Blob) error {
	var err error
	if insert {
		if err = related.Insert(exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"collections\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"logo_blob_id"}),
		strmangle.WhereClause("\"", "\"", 2, collectionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	if _, err = exec.Exec(updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.LogoBlobID, related.ID)
	if o.R == nil {
		o.R = &collectionR{
			LogoBlob: related,
		}
	} else {
		o.R.LogoBlob = related
	}

	if related.R == nil {
		related.R = &blobR{
			LogoBlobCollections: CollectionSlice{o},
		}
	} else {
		related.R.LogoBlobCollections = append(related.R.LogoBlobCollections, o)
	}

	return nil
}

// RemoveLogoBlob relationship.
// Sets o.R.LogoBlob to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Collection) RemoveLogoBlob(exec boil.Executor, related *Blob) error {
	var err error

	queries.SetScanner(&o.LogoBlobID, nil)
	if _, err = o.Update(exec, boil.Whitelist("logo_blob_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.LogoBlob = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.LogoBlobCollections {
		if queries.Equal(o.LogoBlobID, ri.LogoBlobID) {
			continue
		}

		ln := len(related.R.LogoBlobCollections)
		if ln > 1 && i < ln-1 {
			related.R.LogoBlobCollections[i] = related.R.LogoBlobCollections[ln-1]
		}
		related.R.LogoBlobCollections = related.R.LogoBlobCollections[:ln-1]
		break
	}
	return nil
}

// AddItemOnchainTransactions adds the given related objects to the existing relationships
// of the collection, optionally inserting them as new records.
// Appends related to o.R.ItemOnchainTransactions.
// Sets related.R.Collection appropriately.
func (o *Collection) AddItemOnchainTransactions(exec boil.Executor, insert bool, related ...*ItemOnchainTransaction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CollectionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"item_onchain_transactions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"collection_id"}),
				strmangle.WhereClause("\"", "\"", 2, itemOnchainTransactionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CollectionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &collectionR{
			ItemOnchainTransactions: related,
		}
	} else {
		o.R.ItemOnchainTransactions = append(o.R.ItemOnchainTransactions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &itemOnchainTransactionR{
				Collection: o,
			}
		} else {
			rel.R.Collection = o
		}
	}
	return nil
}

// AddPurchasedItemsOlds adds the given related objects to the existing relationships
// of the collection, optionally inserting them as new records.
// Appends related to o.R.PurchasedItemsOlds.
// Sets related.R.Collection appropriately.
func (o *Collection) AddPurchasedItemsOlds(exec boil.Executor, insert bool, related ...*PurchasedItemsOld) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CollectionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"purchased_items_old\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"collection_id"}),
				strmangle.WhereClause("\"", "\"", 2, purchasedItemsOldPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CollectionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &collectionR{
			PurchasedItemsOlds: related,
		}
	} else {
		o.R.PurchasedItemsOlds = append(o.R.PurchasedItemsOlds, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &purchasedItemsOldR{
				Collection: o,
			}
		} else {
			rel.R.Collection = o
		}
	}
	return nil
}

// AddStoreItems adds the given related objects to the existing relationships
// of the collection, optionally inserting them as new records.
// Appends related to o.R.StoreItems.
// Sets related.R.Collection appropriately.
func (o *Collection) AddStoreItems(exec boil.Executor, insert bool, related ...*StoreItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CollectionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"store_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"collection_id"}),
				strmangle.WhereClause("\"", "\"", 2, storeItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CollectionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &collectionR{
			StoreItems: related,
		}
	} else {
		o.R.StoreItems = append(o.R.StoreItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &storeItemR{
				Collection: o,
			}
		} else {
			rel.R.Collection = o
		}
	}
	return nil
}

// AddUserAssets adds the given related objects to the existing relationships
// of the collection, optionally inserting them as new records.
// Appends related to o.R.UserAssets.
// Sets related.R.Collection appropriately.
func (o *Collection) AddUserAssets(exec boil.Executor, insert bool, related ...*UserAsset) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CollectionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_assets\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"collection_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAssetPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CollectionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &collectionR{
			UserAssets: related,
		}
	} else {
		o.R.UserAssets = append(o.R.UserAssets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAssetR{
				Collection: o,
			}
		} else {
			rel.R.Collection = o
		}
	}
	return nil
}

// AddUserAssets1155S adds the given related objects to the existing relationships
// of the collection, optionally inserting them as new records.
// Appends related to o.R.UserAssets1155S.
// Sets related.R.Collection appropriately.
func (o *Collection) AddUserAssets1155S(exec boil.Executor, insert bool, related ...*UserAssets1155) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CollectionID = o.ID
			if err = rel.Insert(exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_assets_1155\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"collection_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAssets1155PrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}
			if _, err = exec.Exec(updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CollectionID = o.ID
		}
	}

	if o.R == nil {
		o.R = &collectionR{
			UserAssets1155S: related,
		}
	} else {
		o.R.UserAssets1155S = append(o.R.UserAssets1155S, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAssets1155R{
				Collection: o,
			}
		} else {
			rel.R.Collection = o
		}
	}
	return nil
}

// Collections retrieves all the records using an executor.
func Collections(mods ...qm.QueryMod) collectionQuery {
	mods = append(mods, qm.From("\"collections\""), qmhelper.WhereIsNull("\"collections\".\"deleted_at\""))
	return collectionQuery{NewQuery(mods...)}
}

// FindCollection retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCollection(exec boil.Executor, iD string, selectCols ...string) (*Collection, error) {
	collectionObj := &Collection{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"collections\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(nil, exec, collectionObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "boiler: unable to select from collections")
	}

	if err = collectionObj.doAfterSelectHooks(exec); err != nil {
		return collectionObj, err
	}

	return collectionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Collection) Insert(exec boil.Executor, columns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no collections provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.UpdatedAt.IsZero() {
		o.UpdatedAt = currTime
	}
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(collectionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	collectionInsertCacheMut.RLock()
	cache, cached := collectionInsertCache[key]
	collectionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			collectionAllColumns,
			collectionColumnsWithDefault,
			collectionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(collectionType, collectionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(collectionType, collectionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"collections\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"collections\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "boiler: unable to insert into collections")
	}

	if !cached {
		collectionInsertCacheMut.Lock()
		collectionInsertCache[key] = cache
		collectionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(exec)
}

// Update uses an executor to update the Collection.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Collection) Update(exec boil.Executor, columns boil.Columns) (int64, error) {
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime

	var err error
	if err = o.doBeforeUpdateHooks(exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	collectionUpdateCacheMut.RLock()
	cache, cached := collectionUpdateCache[key]
	collectionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			collectionAllColumns,
			collectionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("boiler: unable to update collections, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"collections\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, collectionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(collectionType, collectionMapping, append(wl, collectionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}
	var result sql.Result
	result, err = exec.Exec(cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update collections row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by update for collections")
	}

	if !cached {
		collectionUpdateCacheMut.Lock()
		collectionUpdateCache[key] = cache
		collectionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(exec)
}

// UpdateAll updates all rows with the specified column values.
func (q collectionQuery) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all for collections")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected for collections")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CollectionSlice) UpdateAll(exec boil.Executor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("boiler: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), collectionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"collections\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, collectionPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to update all in collection slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to retrieve rows affected all in update all collection")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Collection) Upsert(exec boil.Executor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("boiler: no collections provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	o.UpdatedAt = currTime
	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(collectionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	collectionUpsertCacheMut.RLock()
	cache, cached := collectionUpsertCache[key]
	collectionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			collectionAllColumns,
			collectionColumnsWithDefault,
			collectionColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			collectionAllColumns,
			collectionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("boiler: unable to upsert collections, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(collectionPrimaryKeyColumns))
			copy(conflict, collectionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"collections\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(collectionType, collectionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(collectionType, collectionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRow(cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.Exec(cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "boiler: unable to upsert collections")
	}

	if !cached {
		collectionUpsertCacheMut.Lock()
		collectionUpsertCache[key] = cache
		collectionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(exec)
}

// Delete deletes a single Collection record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Collection) Delete(exec boil.Executor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("boiler: no Collection provided for delete")
	}

	if err := o.doBeforeDeleteHooks(exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), collectionPrimaryKeyMapping)
		sql = "DELETE FROM \"collections\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"collections\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(collectionType, collectionMapping, append(wl, collectionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete from collections")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by delete for collections")
	}

	if err := o.doAfterDeleteHooks(exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q collectionQuery) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("boiler: no collectionQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.Exec(exec)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from collections")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for collections")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CollectionSlice) DeleteAll(exec boil.Executor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(collectionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), collectionPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"collections\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, collectionPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), collectionPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"collections\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, collectionPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}
	result, err := exec.Exec(sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "boiler: unable to delete all from collection slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "boiler: failed to get rows affected by deleteall for collections")
	}

	if len(collectionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Collection) Reload(exec boil.Executor) error {
	ret, err := FindCollection(exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CollectionSlice) ReloadAll(exec boil.Executor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CollectionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), collectionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"collections\".* FROM \"collections\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, collectionPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(nil, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "boiler: unable to reload all in CollectionSlice")
	}

	*o = slice

	return nil
}

// CollectionExists checks if the Collection row exists.
func CollectionExists(exec boil.Executor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"collections\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}
	row := exec.QueryRow(sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "boiler: unable to check if collections exists")
	}

	return exists, nil
}
